## Предотвращение мутаций

**СОДЕРЖАНИЕ:**
- [Метод Object.assign](#1)
- [Библиотека merge-options - глубокое слияние объектов](#2)
- [Метод Object.freeze - неглубокая заморозка объектов и массивов](#3)
- [Библиотека deep-freeze - глубокая заморозка объектов и массивов](#4) 

---

В разделе "Мутации, простые и составные типы данных" был рассмотрен следующий пример:
```js
var obj = { a: 1 };
var newObj = obj;

newObj.a = 25;

console.log(obj); // { a: 25 }
console.log(newObj); // { a: 25 }
```

В результате выполнения кода выше - произошла мутация, в результате которой изменения в объекте newObj отобразились на объекте obj. Исправить ситуацию можно с помощью Object.assign():
```js
var obj = { a: 1 };
var newObj = Object.assign({}, obj);

newObj.a = 25;

console.log(obj); // { a: 1 }
console.log(newObj); // { a: 25 }
```

<a id="1"></a>

## Метод Object.assign

**Object.assign** - копирует свойства одного и более объектов в целевой объект. После копирования возвращает целевой объект:
```js
var obj = { a: 1, b: 2 };

// {} - создаем пустой объект (целевой объект)
// obj - добавляем в него все свойства объекта 'obj'
// { c: 3 } - добавляем в него свойство 'c'
var copy = Object.assign({}, obj, { c: 3 });

console.log(copy); // { a: 1, b: 2, c: 3 }
```

Object.assign хорошо справляется при не глубоком клонировании массивов:
```js
var arr = [1, 2, [10, 20]]

var clone = Object.assign([], arr)
clone.push(7);

console.log(arr); // [1, 2, [10, 20]]
console.log(clone); // [1, 2, [10, 20], 7]
```

Если объекты имеют одинаковые имена свойств, то последующие свойства перезаписывают предыдущие:
```js
let obj1 = { x: 1 };
let obj2 = { y: 2, z: 3 };
let obj3 = { y: 4 };

let copy = Object.assign({}, obj1, obj2, obj3);

console.log(copy); // { x: 1, y: 4, z: 3 }
```

Такое поведение, когда последующие свойства перезаписывают предыдущие, может быть опасным, например:
```js
let obj1 = { x: 1 };
let obj2 = { y: { a: 10, b: 20 }, z: 3 };
let obj3 = { y: { a: 100 } };

let copy = Object.assign({}, obj1, obj2, obj3);

console.log(copy); // { x: 1, y: { a: 100 }, z: 3 }
```

В результате выполнения кода выше, свойство obj3.y, перезаписало свойство obj2.y, как и ожидалось, но при этом свойство obj2.y.b - утеряно. Если необходимо получить результат вида '{ x: 1, y: { a: 100, b: 20 }, z: 3 }', то можно использовать библиотеку **merge-options**.

<a id="2"></a>

## Библиотека merge-options - глубокое слияние объектов

Библиотека [merge-options](https://www.npmjs.com/package/merge-options) позволяет выполнять глубокое слияние объектов (установка `npm i merge-options`):
```js
const mergeOptions = require('merge-options'); // подключаем библиотеку

let obj1 = { x: 1 };
let obj2 = { y: { a: 10, b: 20 }, z: 3 };
let obj3 = { y: { a: 100 } };

let copy = mergeOptions({}, obj1, obj2, obj3); // вместо Object.assign() используем mergeOptions()

console.log(copy); // { x: 1, y: { a: 100, b: 20 }, z: 3 }
```

<a id="3"></a>

## Метод Object.freeze - неглубокая заморозка объектов и массивов

**Object.freeze** - выполняет неглубокую заморозку объекта - это значит, что он:
- предотвращает добавление новых свойств к объекту 
- удаление старых свойств из объекта 
- изменение существующих свойств объекта

**Работа с объектом:**
```js
var obj = { a: 1, b: 2 };

Object.freeze(obj); // Заморозка объект

// Попытка изменения свойства потерпит неудачу без сообщений об ошибках,
// а при 'use strict' - произойдет  выброс исключения TypeError
obj.a = 100;

console.log(obj); // { a: 1, b: 2 }
```

Но Object.freeze() позволяет изменить свойства-объекты «замороженного» объекта:
```js
var obj = { a: 1, b: { key: 2 } };

Object.freeze(obj); // Заморозка объекта

// Попытка изменения свойства потерпит неудачу без сообщений об ошибках,
// а при 'use strict' - произойдет  выброс исключения TypeError
obj.a = 100;

// Попытка изменить свойство-объект «замороженного» объекта -
// будет выполнена успешно
obj.b.key = 200;

console.log(obj); // { a: 1, b: { key: 200 } }
```

> Для предотвращения мутации свойств-объектов - можно использовать библиотеку **deep-freeze**.

**Работа с массивом:**
```js
var arr = [1, 2, 3];

Object.freeze(arr); // Заморозка массива

// Попытка удалить первый элемент массива потерпит неудачу - произойдет  выброс исключения TypeError
// в 'use strict' и обычном режимах
try {
	arr.shift(); 
} catch (error) {
	console.log("error =>", error);
}

console.log(arr); // [1, 2, 3]
```

Но Object.freeze() позволяет изменить вложенные массивы «замороженного» массива:
```js
var arr = [1, 2, [100, 200]];

Object.freeze(arr); // Заморозка массива

// Попытка изменить вложенный массив «замороженного» массива -
// будет выполнена успешно
arr[2].push(300);

console.log(arr); // [1, 2, [100, 200, 300]]
```

<a id="4"></a>

## Библиотека deep-freeze - глубокая заморозка объектов и массивов

Библиотека [mdeep-freeze](https://www.npmjs.com/package/deep-freeze) предотвращает мутации свойств-объектов для объектов и вложенных массивов для массивов (установка `npm i deep-freeze`):
```js
var deepFreeze = require('deep-freeze');

var obj = { a: 1, b: { key: 2 } };

deepFreeze(obj); // Глубокая заморозка объекта 

// Попытка изменения свойства потерпит неудачу без сообщений об ошибках,
// а при 'use strict' - произойдет  выброс исключения TypeError
obj.a = 100;

// Попытка изменить свойство-объект «замороженного» объекта -
// потерпит неудачу
obj.b.key = 200;

console.log(obj); // { a: 1, b: { key: 2 } }
```

```js
var deepFreeze = require('deep-freeze');

var arr = [1, 2, [100, 200]];

deepFreeze(arr); // Заморозка массива

// Попытка удалить первый элемент вложенного массива потерпит неудачу - 
// произойдет  выброс исключения TypeError в 'use strict' и обычном режимах
try {
	arr[2].shift();
} catch (error) {
	console.log('=>', error);
}

console.log(arr); // [1, 2, [100, 200]]
```